<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>CyclomaticComplexMethod:GraphVisualizer.kt$GraphVisualizer$fun generateMermaidDiagramAsFlowchart( nodes: Set&lt;Node&gt;, styling: Boolean = true, title: String? = null, ): String</ID>
    <ID>CyclomaticComplexMethod:Handler.kt$Handler$protected fun createWatchedParameter( rawProviders: RawProviders, operator: Operator, assignableSuffixExpression: KotlinExpression? ): BaseProvider</ID>
    <ID>CyclomaticComplexMethod:OperatorHandler.kt$OperatorHandler$fun handle(expression: OperatorExpression): Provider</ID>
    <ID>CyclomaticComplexMethod:PatternParser.kt$PatternParser$private fun visit(tree: ParseTree): KotlinExpression</ID>
    <ID>CyclomaticComplexMethod:PatternParser.kt$PatternParser$private fun visitBinaryOperator(context: ParseTree): BinaryOperator</ID>
    <ID>FunctionOnlyReturningConstant:FunctionAndFunctionUniversalConflictResolver.kt$FunctionAndFunctionUniversalConflictResolver$private fun genericPropertiesAreEqual(current: FunctionNode, conflicting: FunctionNode): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:FunctionAndFunctionUniversalConflictResolver.kt$FunctionAndFunctionUniversalConflictResolver$private fun modifiersAreEqual(current: FunctionNode, conflicting: FunctionNode): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:FunctionAndFunctionUniversalConflictResolver.kt$FunctionAndFunctionUniversalConflictResolver$private fun parametersAreEqual(current: FunctionNode, conflicting: FunctionNode): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:FunctionStaticUserCodeConflictDetector.kt$FunctionStaticUserCodeConflictDetector$fun hasConflicts(node: FunctionNode): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:PropertyAndPropertyUniversalConflictResolver.kt$PropertyAndPropertyUniversalConflictResolver$private fun genericPropertiesAreEqual(current: PropertyNode, conflicting: PropertyNode): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:PropertyAndPropertyUniversalConflictResolver.kt$PropertyAndPropertyUniversalConflictResolver$private fun modifiersAreEqual(current: PropertyNode, conflicting: PropertyNode): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:PropertyStaticUserCodeConflictDetector.kt$PropertyStaticUserCodeConflictDetector$fun hasConflicts(node: PropertyNode): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:TypeStaticUserCodeConflictDetector.kt$TypeStaticUserCodeConflictDetector$fun hasConflicts(node: TypeNode): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:UserCodeConflictDetector.kt$UserCodeConflictDetector$fun isTypeNameOccupied(namespaceNode: NamespaceNode, typeName: String): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:UserCodeConflictDetector.kt$UserCodeConflictDetector$private fun hasDynamicConflicts(node: Node): Boolean</ID>
    <ID>LongMethod:GraphVisualizer.kt$GraphVisualizer$fun generateMermaidDiagramAsFlowchart( nodes: Set&lt;Node&gt;, styling: Boolean = true, title: String? = null, ): String</ID>
    <ID>LongMethod:JsonObjectBuilderTest.kt$JsonObjectBuilderTest$@Test fun test()</ID>
    <ID>LongMethod:ParserSuccessTest.kt$PatternParserTestParameterized.Companion$@JvmStatic @Parameterized.Parameters fun data()</ID>
    <ID>LongMethod:PatternParser.kt$PatternParser$private fun visit(tree: ParseTree): KotlinExpression</ID>
    <ID>LongParameterList:ContextConstructorMethod.kt$ContextConstructorMethod$( packageName: String, name: String, returnedType: TypeName, receiverType: TypeName?, parameters: List&lt;EntryParameter&gt;, contextName: String, val declaringType: TypeName, origin: Origin )</ID>
    <ID>LongParameterList:ContextCreatorMethod.kt$ContextCreatorMethod$( packageName: String, name: String, returnedType: TypeName, receiverType: TypeName?, parameters: List&lt;EntryParameter&gt;, val contextName: String, origin: Origin )</ID>
    <ID>LongParameterList:ExtensionLambdaProvider.kt$ExtensionLambdaProvider$( typeNode: TypeNode, returningProvider: BaseProvider, //todo don't need? //todo rename val contextMediatorTypeNode: TypeNode, val contextCreatorDefinition: ContextCreatorDefinition, val destinationParameterTypeNode: TypeNode, analyzer: Analyzer, origin: Origin? = null, )</ID>
    <ID>LongParameterList:GlobalPatternMethod.kt$GlobalPatternMethod$( packageName: String, name: String, returnedType: TypeName, receiverType: TypeName?, parameters: List&lt;EntryParameter&gt;, pattern: String, origin: Origin )</ID>
    <ID>LongParameterList:LocalPatternMethod.kt$LocalPatternMethod$( packageName: String, name: String, returnedType: TypeName, receiverType: TypeName?, parameters: List&lt;EntryParameter&gt;, pattern: String, val declaringType: TypeName, origin: Origin )</ID>
    <ID>LongParameterList:PatternMethod.kt$PatternMethod$( packageName: String, name: String, returnedType: TypeName, receiverType: TypeName?, parameters: List&lt;EntryParameter&gt;, val pattern: String, //todo get origin of pattern annotation as well origin: Origin )</ID>
    <ID>MagicNumber:PatternParser.kt$PatternParser$3</ID>
    <ID>MagicNumber:ProcessingInputRenderer.kt$3</ID>
    <ID>MagicNumber:ProcessingInputRenderer.kt$4</ID>
    <ID>MatchingDeclarationName:ContextConstructorAloneTest.kt$ContextConstructorTest : BaseKspFrontendProcessorTest</ID>
    <ID>MaxLineLength:OperatorHandler.kt$OperatorHandler$val rawProvidersOfAssign = RawProviders(rawProviders.providersList + assigningParameter, operatorInfoParameter = null)</ID>
    <ID>MemberNameEqualsClassName:OperatorInfoTypes.kt$OperatorInfoTypes$private val operatorInfoTypes = listOf( EQUALITY_INFO_TYPE, INCLUSION_INFO_TYPE, RANKING_COMPARISON_INFO_TYPE, STRICTNESS_COMPARISON_INFO_TYPE, )</ID>
    <ID>PrintStackTrace:KspFrontendProcessor.kt$KspFrontendProcessor$e</ID>
    <ID>ReturnCount:FunctionAndFunctionUniversalConflictResolver.kt$FunctionAndFunctionUniversalConflictResolver$private fun returnTypesAreMergeable(current: FunctionNode, conflicting: FunctionNode): Boolean</ID>
    <ID>ReturnCount:IdentifierHandler.kt$IdentifierHandler$private fun createProperty(expression: IdentifierLeaf): BaseProvider</ID>
    <ID>ReturnCount:KspFrontendProcessor.kt$KspFrontendProcessor$override fun process(resolver: Resolver): List&lt;KSAnnotated&gt;</ID>
    <ID>ReturnCount:LambdaHandler.kt$LambdaHandler$fun handle(expression: LambdaExpression): Provider</ID>
    <ID>ReturnCount:OperatorHandler.kt$OperatorHandler$fun handle(expression: OperatorExpression): Provider</ID>
    <ID>ReturnCount:ProviderContainer.kt$ProviderContainer$fun Provider.reversedPart(provider: Provider) : MutableList&lt;Provider&gt;</ID>
    <ID>ReturnCount:ProviderContainer.kt$ProviderContainer$fun findProvider(condition: (Provider) -&gt; Boolean): Provider?</ID>
    <ID>SpreadOperator:MethodsRegistry.kt$MethodsRegistry$( "Context creators for one context name '$contextName' must have the same return type\n " + "$groupedByExtensionContextType", *methods.toTypedArray() )</ID>
    <ID>TooGenericExceptionCaught:KspFrontendProcessor.kt$KspFrontendProcessor$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PatternParser.kt$PatternParser$e: Exception</ID>
    <ID>TooGenericExceptionCaught:node.kt$AbstractNode$e: Exception</ID>
    <ID>TooGenericExceptionThrown:JsonUtils.kt$throw RuntimeException(e)</ID>
    <ID>TooManyFunctions:FunctionBlockContext.kt$FunctionBlockContext</ID>
    <ID>TooManyFunctions:Integrator.kt$Integrator</ID>
    <ID>TooManyFunctions:InterceptingLogger.kt$InterceptingLogger : KLogger</ID>
    <ID>TooManyFunctions:TypeConflictChecker.kt$TypeConflictChecker : ConflictChecker</ID>
    <ID>UnnecessaryAbstractClass:SimpleScript.kt$SimpleScript$SimpleScript</ID>
    <ID>UnusedPrivateMember:BaseKspFrontendProcessorTest.kt$BaseKspFrontendProcessorTest$private fun KotlinCompilation.Result.kspGeneratedSources(): List&lt;File&gt;</ID>
    <ID>UnusedPrivateMember:FunctionStaticUserCodeConflictDetector.kt$FunctionStaticUserCodeConflictDetector$node: FunctionNode</ID>
    <ID>UnusedPrivateMember:PropertyStaticUserCodeConflictDetector.kt$PropertyStaticUserCodeConflictDetector$node: PropertyNode</ID>
    <ID>UnusedPrivateMember:TypeStaticUserCodeConflictDetector.kt$TypeStaticUserCodeConflictDetector$node: TypeNode</ID>
    <ID>UnusedPrivateMember:TypeUtils.kt$callableReference: KSCallableReference</ID>
    <ID>UnusedPrivateMember:UserCodeConflictDetector.kt$UserCodeConflictDetector$namespaceNode: NamespaceNode</ID>
    <ID>UnusedPrivateMember:UserCodeConflictDetector.kt$UserCodeConflictDetector$node: Node</ID>
    <ID>UnusedPrivateMember:UserCodeConflictDetector.kt$UserCodeConflictDetector$typeName: String</ID>
    <ID>UnusedPrivateMember:Utils.kt$private const val FILENAME = "Generated"</ID>
  </CurrentIssues>
</SmellBaseline>
